<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>å®Œæ•´æœç´¢æ¸¬è©¦</title>
  <style>
    body { font-family: monospace; padding: 20px; }
    .success { color: green; }
    .error { color: red; }
    .info { color: blue; }
    pre { background: #f5f5f5; padding: 10px; }
  </style>
</head>
<body>
  <h1>å®Œæ•´æœç´¢é‚è¼¯æ¸¬è©¦</h1>
  <div id="output"></div>
  
  <script>
    const SIMP_TRAD_MAP = {
      'äº§': 'ç”¢', 'å“': 'å“', 'è´¨': 'è³ª', 'é‡': 'é‡', 'ä¾': 'ä¾', 'æ®': 'æ“š', 
      'å‘': 'ç™¼', 'ç°': 'ç¾', 'ç¨‹': 'ç¨‹', 'åº¦': 'åº¦', 'é—®': 'å•', 'é¢˜': 'é¡Œ',
      'å®': 'å¯¦', 'é™…': 'éš›', 'æ ·': 'æ¨£', 'æœ¬': 'æœ¬', 'ä¹¦': 'æ›¸', 'è®°': 'è¨˜',
      'å½•': 'éŒ„', 'å‡†': 'æº–', 'å¤‡': 'å‚™', 'ç¡®': 'ç¢º', 'è®¤': 'èª', 'è´§': 'è²¨',
      'è¿': 'é‹', 'è¾“': 'è¼¸', 'é•¿': 'é•·', 'æœŸ': 'æœŸ', 'è½¦': 'è»Š', 'é—´': 'é–“',
      'åº”': 'æ‡‰', 'è¯¥': 'è©²', 'å¯¹': 'å°', 'å¼€': 'é–‹', 'å…³': 'é—œ', 'ç³»': 'ä¿‚',
      'æ°”': 'æ°£', 'ä¸¤': 'å…©', 'ä¸¥': 'åš´', 'æ ¼': 'æ ¼', 'æŠ¥': 'å ±', 'å‘Š': 'å‘Š',
      'åŠ¡': 'å‹™', 'å‘˜': 'å“¡', 'ä¸ª': 'å€‹', 'ä½“': 'é«”', 'è¡¨': 'è¡¨', 'é¢': 'é¢',
      'åˆ¶': 'è£½', 'é€ ': 'é€ ', 'ç ': 'ç¢¼', 'ä¸“': 'å°ˆ', 'ä¸š': 'æ¥­', 'é¡¹': 'é …',
      'ä¹ˆ': 'éº¼', 'ä»€': 'ç”š', 'èŒƒ': 'ç¯„', 'è§„': 'è¦', 'åˆ’': 'åŠƒ',
      'åŸ¹': 'åŸ¹', 'è®­': 'è¨“', 'å­¦': 'å­¸', 'ä¹ ': 'ç¿’', 'ç»ƒ': 'ç·´',
      'æ£€': 'æª¢', 'éªŒ': 'é©—', 'æµ‹': 'æ¸¬', 'è¯•': 'è©¦', 'æ ‡': 'æ¨™', 'æŸ¥': 'æŸ¥',
      'è¿‡': 'é', 'å¤„': 'è™•', 'ç†': 'ç†', 'æ—¶': 'æ™‚', 'æœ¯': 'è¡“', 'æŠ€': 'æŠ€',
      'çº¿': 'ç·š', 'å·': 'è™Ÿ', 'å•': 'å–®', 'ç»„': 'çµ„', 'ç»‡': 'ç¹”', 'è®¾': 'è¨­',
      'è®¡': 'è¨ˆ', 'èµ„': 'è³‡', 'æ–™': 'æ–™', 'æ¡£': 'æª”', 'æ¡ˆ': 'æ¡ˆ', 'åº“': 'åº«',
      'åŒº': 'å€', 'ç¯': 'ç’°', 'å¢ƒ': 'å¢ƒ', 'åœº': 'å ´', 'é™©': 'éšª',
      'å±‚': 'å±¤', 'çº§': 'ç´š', 'å˜': 'è®Š', 'æ¢': 'æ›', 'è½¬': 'è½‰', 'æ€': 'æ…‹'
    };

    const STOP_WORDS = new Set([
      'ä»€éº¼', 'ä»€ä¹ˆ', 'æ˜¯', 'çš„', 'å—', 'å—', 'æ€éº¼', 'æ€ä¹ˆ', 'å¦‚ä½•', 'ç‚º', 'ä¸º', 'äº†', '?', 'ï¼Ÿ', 'èƒ½', 'ä¸èƒ½', 'æœ‰', 'æ²’æœ‰', 'æ²¡æœ‰', 'æˆ‘', 'æƒ³', 'å•', 'é—®', 'æœ‰å“ªäº›', 'å“ªäº›', 'é—œæ–¼', 'å…³äº', 'åŒ…å«', 'åŒ…æ‹¬'
    ]);

    const createFlexibleRegex = (text) => {
      let pattern = '';
      for (let char of text) {
        if (/[a-zA-Z0-9]/.test(char)) {
          pattern += char; 
        } else {
          const trad = SIMP_TRAD_MAP[char]; 
          const reverseKey = Object.keys(SIMP_TRAD_MAP).find(k => SIMP_TRAD_MAP[k] === char); 
          
          if (trad) pattern += `(${char}|${trad})`;
          else if (reverseKey) pattern += `(${char}|${reverseKey})`;
          else pattern += char; 
        }
      }
      return new RegExp(pattern, 'gi');
    };

    const cleanHeader = (line) => {
      return line.replace(/^[#\s]+(Q:|å•ï¼š)?\s*/g, '').trim();
    };

    const chunkDocument = (docId, docTitle, content) => {
      const chunks = [];
      const lines = content.split('\n');
      let currentParentContext = docTitle; 
      let currentChunk = { title: docTitle, body: [], hasRealContent: false };
      let chunkIndex = 0;

      const flushChunk = () => {
        if (currentChunk.hasRealContent && currentChunk.body.length > 0) {
          const fullContent = currentChunk.body.join('\n').trim();
          const combinedTitle = currentParentContext && currentParentContext !== currentChunk.title 
            ? `${currentParentContext} > ${currentChunk.title}` 
            : currentChunk.title;

          chunks.push({
            id: `${docId}-${chunkIndex++}`,
            docId,
            docTitle: docTitle, 
            chunkTitle: currentChunk.title,
            combinedTitle: combinedTitle,
            content: fullContent,
            rawText: (combinedTitle + '\n' + fullContent)
          });
        }
      };

      lines.forEach((line) => {
        const trimmedLine = line.trim();
        if (!trimmedLine) return;
        const isAnswerLine = trimmedLine.match(/^(###\s*)?(A:|ç­”:|Answer:|Ans:)/i);
        const isHeader = (line.startsWith('#') || trimmedLine.match(/^(Q:|Qï¼š|å•:|å•ï¼š|Question:)/i)) && !isAnswerLine;

        if (isHeader) {
          flushChunk();
          const newTitle = cleanHeader(line);
          if (line.startsWith('# ') || line.startsWith('## ')) currentParentContext = newTitle;
          currentChunk = { title: newTitle, body: [line], hasRealContent: false };
        } else {
          currentChunk.body.push(line);
          currentChunk.hasRealContent = true; 
        }
      });
      flushChunk();
      return chunks;
    };

    const sniperSearch = (query, allChunks) => {
      const cleanQuery = query.replace(/[^\w\u4e00-\u9fa5]/g, '');
      const tokens = [];
      for(let char of cleanQuery) {
        if (!STOP_WORDS.has(char)) tokens.push(char);
      }
      const effectiveQuery = tokens.join('');
      
      if (effectiveQuery.length === 0) return [];

      // ç¬¬ä¸€éšæ®µï¼šæ¨™é¡ŒåŒ¹é…
      const perfectMatches = allChunks.filter(chunk => {
        const regex = createFlexibleRegex(effectiveQuery);
        const docTitleMatch = regex.test(chunk.docTitle);
        const chunkTitleMatch = regex.test(chunk.chunkTitle);
        return docTitleMatch || chunkTitleMatch;
      });

      if (perfectMatches.length > 0) {
        return perfectMatches.map(chunk => {
            let score = 1000; 
            const regex = createFlexibleRegex(effectiveQuery);
            if (regex.test(chunk.content)) score += 500;
            if (regex.test(chunk.chunkTitle)) score += 300;
            return { ...chunk, score, debug: { method: 'Title Sniper', exact: true } };
        }).sort((a, b) => b.score - a.score);
      }

      // ç¬¬äºŒéšæ®µï¼šå…§å®¹åŒ¹é…
      return allChunks.map(chunk => {
        let score = 0;
        const chunkText = chunk.rawText; 
        const exactRegex = createFlexibleRegex(effectiveQuery);

        if (exactRegex.test(chunkText)) score += 200;
        if (score === 0) return { ...chunk, score: -1, debug: { method: 'No Match' } };

        let bigramHits = 0;
        for (let i = 0; i < effectiveQuery.length - 1; i++) {
          const bigram = effectiveQuery.substring(i, i+2);
          const bigramRegex = createFlexibleRegex(bigram);
          if (bigramRegex.test(chunkText)) {
            score += 50;
            bigramHits++;
          }
        }

        const lengthPenalty = Math.max(1, Math.log10(chunkText.length));
        let finalScore = score / lengthPenalty;

        return { 
          ...chunk, 
          score: finalScore, 
          debug: { method: 'Content Match', bigramHits }
        };
      })
      .filter(c => c.score > 0)
      .sort((a, b) => b.score - a.score);
    };

    // å¾ API åŠ è¼‰å¯¦éš›æ–‡æª”
    async function runTest() {
      let output = '<h2>æ¸¬è©¦é–‹å§‹</h2>';
      
      try {
        output += '<p class="info">ğŸ“¡ æ­£åœ¨å¾ API è¼‰å…¥æ–‡æª”...</p>';
        const response = await fetch('https://glorious-reprieve-production.up.railway.app/api/documents');
        const docs = await response.json();
        
        output += `<p class="success">âœ… è¼‰å…¥ ${docs.length} å€‹æ–‡æª”</p>`;
        
        // ç”Ÿæˆ chunks
        let allChunks = [];
        docs.forEach(doc => {
          const docChunks = chunkDocument(doc.id, doc.title, doc.content);
          output += `<p class="info">ğŸ“¦ æ–‡æª” "${doc.title}" ç”Ÿæˆ ${docChunks.length} å€‹åˆ‡åˆ†</p>`;
          allChunks = [...allChunks, ...docChunks];
        });
        
        output += `<p class="success">ğŸ“Š ç¸½å…± ${allChunks.length} å€‹åˆ‡åˆ†</p>`;
        
        // æ¸¬è©¦æŸ¥è©¢
        const testQueries = ['åŸ¹è®­', 'åŸ¹è¨“', 'QIP', 'å“è´¨', 'å“è³ª', 'ä»€ä¹ˆæ˜¯å“è´¨ç®¡ç†'];
        
        testQueries.forEach(query => {
          output += `<hr><h3>ğŸ” æŸ¥è©¢: "${query}"</h3>`;
          
          const results = sniperSearch(query, allChunks);
          output += `<p class="info">ğŸ¯ æ‰¾åˆ° ${results.length} å€‹åŒ¹é…</p>`;
          
          if (results.length > 0) {
            output += '<p class="success">âœ… æœç´¢æˆåŠŸï¼å‰ 3 å€‹çµæœï¼š</p><pre>';
            results.slice(0, 3).forEach((r, i) => {
              output += `${i+1}. ${r.chunkTitle} (åˆ†æ•¸: ${r.score.toFixed(2)})\n`;
            });
            output += '</pre>';
          } else {
            output += '<p class="error">âŒ æ²’æœ‰æ‰¾åˆ°åŒ¹é…</p>';
          }
        });
        
      } catch (error) {
        output += `<p class="error">âŒ éŒ¯èª¤: ${error.message}</p>`;
      }
      
      document.getElementById('output').innerHTML = output;
    }
    
    runTest();
  </script>
</body>
</html>
